<!DOCTYPE html>
<body><div class="d"></div>
</body>
<script src="d3.v3.min.js"></script>
<script src="http://cdn.jsdelivr.net/jquery/2.1.4/jquery.min.js"></script>
<script>


// var d3 = require('d3');
// var fs = require('fs');
// fs.writeFile("processed.json", "Hey there!", function(err) {
    // if(err) {
        // return console.log(err);
    // }

    // console.log("The file was saved!");
// });

// Build json hierarchy from csv
d3.csv("batterExport.csv", 
  function(d) {
    return {
      nm: d.Name,
      yr: d.year,
      st: d.set,
      cn: +d.cardNo, // + converts to number
      tm: d.team,
      ob: +d.onbase,
      so: +d.so,
      gb: +d.gb,
      fb: +d.fb,
      outs: +d.so + +d.gb + +d.fb,
      bb: +d.bb,
      b1: +d.b1,
      b2: +d.b2,
      b3: +d.b3,
      hr: +d.hr,
      pt: +d.pts,
      sp: +d.sp,
      hd: d.hand,
      p1: d.pos1,
      f1: +d.fld1,
      p2: d.pos2,
      f2: +d.fld2,
      p3: d.pos3,
      f3: +d.fld3,
      p4: d.pos4,
      f4: +d.fld4
    };
  },
  function(error, root) {
    var ob_element, outs_element, hr_element;
    var ob_max = 0, ob_min = 10, outs_max = 0, outs_min = 10, hr_max = 0, hr_min = 10;
    var newRoot, build;
    var batters = {"name": "batters", "children": []};
    
    // Get min and max of the values we are splitting up by
    root.map(function(a){
      if(a.ob > ob_max) ob_max = a.ob;
      if(a.ob < ob_min) ob_min = a.ob;
      if(a.outs > outs_max) outs_max = a.outs;
      if(a.outs < outs_min) outs_min = a.outs;
      if(a.hr > hr_max) hr_max = a.hr;
      if(a.hr < hr_min) hr_min = a.hr;
    });
    //console.log(ob_max);console.log(ob_min);console.log(outs_max);console.log(outs_min);console.log(hr_max);console.log(hr_min);
    
    // Build the json
    //
    // Notes on the algorithm:
    // Using newRoot (taking out the found values) gives O(n^2). 
    // Using root (not taking out any values as we go) gives O(n!).
    //
    // We *could* get O(n) by putting the nested for-constant loops INSIDE the
    // root.map function. The data structure would have to be pre-built, but then
    // each player could be pushed on to its appropriate place as they are found.
    
    for(var i = ob_min; i <= ob_max; i++){
      ob_element = {"ob": i, "children": []};
      for(var j = outs_min; j <= outs_max; j++){
        outs_element = {"outs": j, "children": []};
        for(var k = hr_min; k <= hr_max; k++){
          hr_element = {"hr": k, "children": []};
          
          found = [];
          newRoot = [];
          root.map(function(val){
            if(val.ob == i && val.outs == j && val.hr == k){
              found.push(val);
            }
            else newRoot.push(val);
          });
          
          // add each found item
          found.map(function(val){
            hr_element.children.push(val);
          });
          
          if(hr_element.children.length > 0) outs_element.children.push(hr_element);
           
          root = newRoot;
          
        }
        
        if(outs_element.children.length > 0) ob_element.children.push(outs_element);
      
      }
      
      batters.children.push(ob_element);
      
    }
    // The results!
    $(".d").html('<pre>'+JSON.stringify(batters, null, '  ')+'</pre>');
  });


</script>